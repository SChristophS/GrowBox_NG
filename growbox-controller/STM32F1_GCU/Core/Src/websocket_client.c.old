#include "websocket_client.h"
#include "socket.h"
#include <string.h>
#include <stdio.h>
#include "wizchip_conf.h"  // Stellen Sie sicher, dass diese Header-Datei die Definitionen enthält

#define BUFFER_SIZE 2048

static uint8_t buffer[BUFFER_SIZE];
static uint16_t SocketPort = 8085;

extern int process_dns(const char *host, uint8_t *destip); // Deklaration von process_dns

int websocket_handshake(int sock, const char *host, const char *path) {
    char request[256];
    sprintf(request, "GET %s HTTP/1.1\r\n"
                     "Host: %s\r\n"
                     "Upgrade: websocket\r\n"
                     "Connection: Upgrade\r\n"
                     "Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\n"
                     "Sec-WebSocket-Version: 13\r\n\r\n",
                     path, host);

    send(sock, (uint8_t *)request, strlen(request));

    int32_t len = recv(sock, buffer, BUFFER_SIZE);
    if (len <= 0) {
        printf("Failed to receive handshake response\n");
        return -1;
    }

    buffer[len] = '\0';
    printf("Handshake response:\n%s\n", buffer);

    if (strstr((char *)buffer, "Sec-WebSocket-Accept")) {
        return 0;
    }

    return -1;
}

int websocket_send(int sock, const char *message) {
    uint8_t frame[BUFFER_SIZE];
    size_t message_len = strlen(message);
    size_t frame_len = 0;

    frame[0] = 0x81;
    if (message_len <= 125) {
        frame[1] = (uint8_t)message_len;
        memcpy(&frame[2], message, message_len);
        frame_len = message_len + 2;
    } else if (message_len <= 65535) {
        frame[1] = 126;
        frame[2] = (message_len >> 8) & 0xFF;
        frame[3] = message_len & 0xFF;
        memcpy(&frame[4], message, message_len);
        frame_len = message_len + 4;
    } else {
        return -1;
    }

    send(sock, frame, frame_len);
    return 0;
}

int websocket_recv(int sock, char *message, size_t max_len) {
    uint8_t frame[BUFFER_SIZE];
    int32_t len = recv(sock, frame, BUFFER_SIZE);
    if (len <= 0) {
        return -1;
    }

    size_t message_len = frame[1] & 0x7F;
    if (message_len <= 125) {
        memcpy(message, &frame[2], message_len);
    } else if (message_len == 126) {
        message_len = (frame[2] << 8) | frame[3];
        memcpy(message, &frame[4], message_len);
    } else {
        return -1;
    }

    message[message_len] = '\0';
    return 0;
}




void socket_network_init(SocketNetwork *n, const char *server_ip, uint16_t server_port, uint16_t local_port) {
    n->server_ip = server_ip;
    n->server_port = server_port;
    n->local_port = local_port;
    n->sock = -1;

    printf("Initialisiere Socket-Netzwerk...\r\n");
    n->sock = socket(SOCK_TCP, Sn_MR_TCP, n->local_port, 0);
    printf("Ergebnis der Socket-Initialisierung: %d\r\n", n->sock);
    if (n->sock < 0) {
        printf("Socket-Initialisierung fehlgeschlagen.\r\n");
    } else {
        printf("Socket erfolgreich initialisiert. Socket Nummer: %d\r\n", n->sock);


       printf("Versuche, Verbindung zum Server herzustellen...\r\n");
       printf("Server IP: %s, Server Port: %d\r\n", n->server_ip, n->server_port);
       printf("Socket Status vor dem Verbinden: %d\r\n", getSn_SR(n->sock));

       //int result = connect(n->sock, (uint8_t *)n->server_ip, n->server_port);
       int result = connect(SOCK_TCP, (uint8_t *)n->server_ip, n->server_port);

       printf("Resultat des Verbindungsversuchs: %d\r\n", result);
       printf("Socket Status nach dem Verbinden: %d\r\n", getSn_SR(n->sock));

       if (result == SOCK_OK) {
           printf("Verbindung zum Server hergestellt.\r\n");


       } else {
           printf("Verbindungsversuch fehlgeschlagen. Fehlercode: %d\r\n", result);
           switch(result) {
               case SOCKERR_TIMEOUT:
                   printf("Fehler: Timeout\r\n");
                   break;
               case SOCKERR_SOCKCLOSED:
                   printf("Fehler: Socket geschlossen\r\n");
                   break;
               case SOCKERR_SOCKINIT:
                   printf("Fehler: Socket nicht initialisiert\r\n");
                   break;
               case SOCKERR_SOCKSTATUS:
                   printf("Fehler: Ungültiger Socket-Status\r\n");
                   break;
               case SOCKERR_ARG:
                   printf("Fehler: Ungültiges Argument\r\n");
                   break;
               default:
                   printf("Unbekannter Fehler\r\n");
                   break;
           }
           disconnect(n->sock);
           n->sock = -1;
       }
    }
}



int connect_to_websocket(const char *host, uint16_t port, const char *path) {
    int32_t ret;

    int sock = socket(SOCK_TCP, Sn_MR_TCP, SocketPort, 0);
    if (sock < 0) {
        printf("Failed to create socket\r\n");
        return -1;
    }
    printf("sock: %d\r\n", sock);

    ret = connect((uint8_t ) sock, (uint8_t *) host, (uint16_t )port);

    printf("ret: %ld\r\n", ret);
    if (ret < 0) {
        printf("Failed to connect to server, error code: %ld\r\n", ret);
        switch (ret) {
            case SOCKERR_SOCKNUM:
                printf("Error: Invalid socket number\r\n");
                break;
            case SOCKERR_SOCKOPT:
                printf("Error: Invalid socket option\r\n");
                break;
            case SOCKERR_SOCKINIT:
                printf("Error: Socket is not initialized or SIPR is Zero IP address\r\n");
                break;
            case SOCKERR_SOCKCLOSED:
                printf("Error: Socket unexpectedly closed\r\n");
                break;
            case SOCKERR_SOCKFLAG:
                printf("Error: Invalid socket flag\r\n");
                break;
            case SOCKERR_TIMEOUT:
                printf("Error: Timeout occurred\r\n");
                break;
            case SOCKERR_DATALEN:
                printf("Error: Data length is zero or greater than buffer max size\r\n");
                break;
            case SOCKERR_BUFFER:
                printf("Error: Socket buffer is not enough\r\n");
                break;
            default:
                printf("Unknown error\r\n");
                break;
        }
        close(sock);
        return -1;
    }

    if (websocket_handshake(sock, host, path) < 0) {
        printf("WebSocket handshake failed\n");
        close(sock);
        return -1;
    }

    return sock;
}
